{"ast":null,"code":"import * as posenet from '@tensorflow-models/posenet';\nconst pointRadius = 3;\nexport const config = {\n  videoWidth: 900,\n  videoHeight: 700,\n  flipHorizontal: true,\n  algorithm: 'single-pose',\n  showVideo: true,\n  showSkeleton: true,\n  showPoints: true,\n  minPoseConfidence: 0.1,\n  minPartConfidence: 0.5,\n  maxPoseDetections: 2,\n  nmsRadius: 20,\n  outputStride: 16,\n  imageScaleFactor: 0.5,\n  skeletonColor: '#ffadea',\n  skeletonLineWidth: 6,\n  loadingText: 'Loading...please be patient...'\n};\n\nfunction toTuple({\n  x,\n  y\n}) {\n  return [x, y];\n}\n\nexport function drawKeyPoints(keypoints, minConfidence, skeletonColor, canvasContext, scale = 1) {\n  keypoints.forEach(keypoint => {\n    if (keypoint.score >= minConfidence) {\n      const {\n        x,\n        y\n      } = keypoint.position;\n      canvasContext.beginPath();\n      canvasContext.arc(x * scale, y * scale, pointRadius, 0, 2 * Math.PI);\n      canvasContext.fillStyle = skeletonColor;\n      canvasContext.fill();\n    }\n  });\n}\n\nfunction drawSegment([firstX, firstY], [nextX, nextY], color, lineWidth, scale, canvasContext) {\n  canvasContext.beginPath();\n  canvasContext.moveTo(firstX * scale, firstY * scale);\n  canvasContext.lineTo(nextX * scale, nextY * scale);\n  canvasContext.lineWidth = lineWidth;\n  canvasContext.strokeStyle = color;\n  canvasContext.stroke();\n}\n\nexport function drawSkeleton(keypoints, minConfidence, color, lineWidth, canvasContext, scale = 1) {\n  const adjacentKeyPoints = posenet.getAdjacentKeyPoints(keypoints, minConfidence);\n  adjacentKeyPoints.forEach(keypoints => {\n    drawSegment(toTuple(keypoints[0].position), toTuple(keypoints[1].position), color, lineWidth, scale, canvasContext);\n  });\n}","map":{"version":3,"sources":["/Users/gaurav_1411/Desktop/XylophoneHero/frontend/src/components/utils.js"],"names":["posenet","pointRadius","config","videoWidth","videoHeight","flipHorizontal","algorithm","showVideo","showSkeleton","showPoints","minPoseConfidence","minPartConfidence","maxPoseDetections","nmsRadius","outputStride","imageScaleFactor","skeletonColor","skeletonLineWidth","loadingText","toTuple","x","y","drawKeyPoints","keypoints","minConfidence","canvasContext","scale","forEach","keypoint","score","position","beginPath","arc","Math","PI","fillStyle","fill","drawSegment","firstX","firstY","nextX","nextY","color","lineWidth","moveTo","lineTo","strokeStyle","stroke","drawSkeleton","adjacentKeyPoints","getAdjacentKeyPoints"],"mappings":"AAAA,OAAO,KAAKA,OAAZ,MAAyB,4BAAzB;AAEA,MAAMC,WAAW,GAAG,CAApB;AAEA,OAAO,MAAMC,MAAM,GAAG;AACpBC,EAAAA,UAAU,EAAE,GADQ;AAEpBC,EAAAA,WAAW,EAAE,GAFO;AAGpBC,EAAAA,cAAc,EAAE,IAHI;AAIpBC,EAAAA,SAAS,EAAE,aAJS;AAKpBC,EAAAA,SAAS,EAAE,IALS;AAMpBC,EAAAA,YAAY,EAAE,IANM;AAOpBC,EAAAA,UAAU,EAAE,IAPQ;AAQpBC,EAAAA,iBAAiB,EAAE,GARC;AASpBC,EAAAA,iBAAiB,EAAE,GATC;AAUpBC,EAAAA,iBAAiB,EAAE,CAVC;AAWpBC,EAAAA,SAAS,EAAE,EAXS;AAYpBC,EAAAA,YAAY,EAAE,EAZM;AAapBC,EAAAA,gBAAgB,EAAE,GAbE;AAcpBC,EAAAA,aAAa,EAAE,SAdK;AAepBC,EAAAA,iBAAiB,EAAE,CAfC;AAgBpBC,EAAAA,WAAW,EAAE;AAhBO,CAAf;;AAmBP,SAASC,OAAT,CAAiB;AAACC,EAAAA,CAAD;AAAIC,EAAAA;AAAJ,CAAjB,EAAyB;AACvB,SAAO,CAACD,CAAD,EAAIC,CAAJ,CAAP;AACD;;AAED,OAAO,SAASC,aAAT,CACLC,SADK,EAELC,aAFK,EAGLR,aAHK,EAILS,aAJK,EAKLC,KAAK,GAAG,CALH,EAML;AACAH,EAAAA,SAAS,CAACI,OAAV,CAAkBC,QAAQ,IAAI;AAC5B,QAAIA,QAAQ,CAACC,KAAT,IAAkBL,aAAtB,EAAqC;AACnC,YAAM;AAACJ,QAAAA,CAAD;AAAIC,QAAAA;AAAJ,UAASO,QAAQ,CAACE,QAAxB;AACAL,MAAAA,aAAa,CAACM,SAAd;AACAN,MAAAA,aAAa,CAACO,GAAd,CAAkBZ,CAAC,GAAGM,KAAtB,EAA6BL,CAAC,GAAGK,KAAjC,EAAwCzB,WAAxC,EAAqD,CAArD,EAAwD,IAAIgC,IAAI,CAACC,EAAjE;AACAT,MAAAA,aAAa,CAACU,SAAd,GAA0BnB,aAA1B;AACAS,MAAAA,aAAa,CAACW,IAAd;AACD;AACF,GARD;AASD;;AAED,SAASC,WAAT,CACE,CAACC,MAAD,EAASC,MAAT,CADF,EAEE,CAACC,KAAD,EAAQC,KAAR,CAFF,EAGEC,KAHF,EAIEC,SAJF,EAKEjB,KALF,EAMED,aANF,EAOE;AACAA,EAAAA,aAAa,CAACM,SAAd;AACAN,EAAAA,aAAa,CAACmB,MAAd,CAAqBN,MAAM,GAAGZ,KAA9B,EAAqCa,MAAM,GAAGb,KAA9C;AACAD,EAAAA,aAAa,CAACoB,MAAd,CAAqBL,KAAK,GAAGd,KAA7B,EAAoCe,KAAK,GAAGf,KAA5C;AACAD,EAAAA,aAAa,CAACkB,SAAd,GAA0BA,SAA1B;AACAlB,EAAAA,aAAa,CAACqB,WAAd,GAA4BJ,KAA5B;AACAjB,EAAAA,aAAa,CAACsB,MAAd;AACD;;AAED,OAAO,SAASC,YAAT,CACLzB,SADK,EAELC,aAFK,EAGLkB,KAHK,EAILC,SAJK,EAKLlB,aALK,EAMLC,KAAK,GAAG,CANH,EAOL;AACA,QAAMuB,iBAAiB,GAAGjD,OAAO,CAACkD,oBAAR,CACxB3B,SADwB,EAExBC,aAFwB,CAA1B;AAKAyB,EAAAA,iBAAiB,CAACtB,OAAlB,CAA0BJ,SAAS,IAAI;AACrCc,IAAAA,WAAW,CACTlB,OAAO,CAACI,SAAS,CAAC,CAAD,CAAT,CAAaO,QAAd,CADE,EAETX,OAAO,CAACI,SAAS,CAAC,CAAD,CAAT,CAAaO,QAAd,CAFE,EAGTY,KAHS,EAITC,SAJS,EAKTjB,KALS,EAMTD,aANS,CAAX;AAQD,GATD;AAUD","sourcesContent":["import * as posenet from '@tensorflow-models/posenet'\n\nconst pointRadius = 3\n\nexport const config = {\n  videoWidth: 900,\n  videoHeight: 700,\n  flipHorizontal: true,\n  algorithm: 'single-pose',\n  showVideo: true,\n  showSkeleton: true,\n  showPoints: true,\n  minPoseConfidence: 0.1,\n  minPartConfidence: 0.5,\n  maxPoseDetections: 2,\n  nmsRadius: 20,\n  outputStride: 16,\n  imageScaleFactor: 0.5,\n  skeletonColor: '#ffadea',\n  skeletonLineWidth: 6,\n  loadingText: 'Loading...please be patient...'\n}\n\nfunction toTuple({x, y}) {\n  return [x, y]\n}\n\nexport function drawKeyPoints(\n  keypoints,\n  minConfidence,\n  skeletonColor,\n  canvasContext,\n  scale = 1\n) {\n  keypoints.forEach(keypoint => {\n    if (keypoint.score >= minConfidence) {\n      const {x, y} = keypoint.position\n      canvasContext.beginPath()\n      canvasContext.arc(x * scale, y * scale, pointRadius, 0, 2 * Math.PI)\n      canvasContext.fillStyle = skeletonColor\n      canvasContext.fill()\n    }\n  })\n}\n\nfunction drawSegment(\n  [firstX, firstY],\n  [nextX, nextY],\n  color,\n  lineWidth,\n  scale,\n  canvasContext\n) {\n  canvasContext.beginPath()\n  canvasContext.moveTo(firstX * scale, firstY * scale)\n  canvasContext.lineTo(nextX * scale, nextY * scale)\n  canvasContext.lineWidth = lineWidth\n  canvasContext.strokeStyle = color\n  canvasContext.stroke()\n}\n\nexport function drawSkeleton(\n  keypoints,\n  minConfidence,\n  color,\n  lineWidth,\n  canvasContext,\n  scale = 1\n) {\n  const adjacentKeyPoints = posenet.getAdjacentKeyPoints(\n    keypoints,\n    minConfidence\n  )\n\n  adjacentKeyPoints.forEach(keypoints => {\n    drawSegment(\n      toTuple(keypoints[0].position),\n      toTuple(keypoints[1].position),\n      color,\n      lineWidth,\n      scale,\n      canvasContext\n    )\n  })\n}\n"]},"metadata":{},"sourceType":"module"}